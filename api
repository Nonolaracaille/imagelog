#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DreamLover — Mod Menu IP Checker (IPv4 + IP info)
- Génère uniquement des adresses IPv4 dans des plages réservées / privées / link-local / loopback.
- Préfixe "[+]" devant chaque IP.
- Nouvelle option: IP info -> entre une IP IPv4 et le script tente de géolocaliser (pays, ville, lat/lon)
  puis ouvre une carte (Leaflet) avec un point rouge.
- Dossier de sortie carte HTML : ~/dreamlover_maps
"""

import time
import random
import sys
import json
import webbrowser
import urllib.parse
import os
from datetime import datetime

try:
    import requests
except Exception:
    requests = None

# --- CONFIG ---
INTERVAL = 2  # secondes entre chaque affichage (modifiable)
MAP_OUTPUT_DIR = os.path.expanduser("~/dreamlover_maps")
os.makedirs(MAP_OUTPUT_DIR, exist_ok=True)

# --- Couleurs (colorama si installé, sinon séquences ANSI basiques) ---
try:
    from colorama import init as colorama_init, Fore, Style
    colorama_init()
except Exception:
    class Fore:
        RED = "\033[31m"
        GREEN = "\033[32m"
        YELLOW = "\033[33m"
        BLUE = "\033[34m"
        MAGENTA = "\033[35m"
        CYAN = "\033[36m"
        RESET = "\033[39m"
    class Style:
        BRIGHT = "\033[1m"
        NORMAL = "\033[0m"
        RESET_ALL = "\033[0m"

# --- Helpers ---
def now_str():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def banner():
    print(Style.BRIGHT + Fore.CYAN + r"""
  ____                                     _                     _             
 |  _ \  ___  _ __ ___   ___  _ __   ___  | |    ___   __ _  ___| | _____ _ __ 
 | | | |/ _ \| '_ ` _ \ / _ \| '_ \ / _ \ | |   / _ \ / _` |/ __| |/ / _ \ '__|
 | |_| | (_) | | | | | | (_) | | | |  __/ | |__| (_) | (_| | (__|   <  __/ |   
 |____/ \___/|_| |_| |_|\___/|_| |_|\___| |_____\___/ \__,_|\___|_|\_\___|_|   

""" + Style.RESET_ALL)
    print(Fore.YELLOW + "  DreamLover — Mod Menu IP Checker (IPv4 + IP info)" + Fore.RESET)
    print(Fore.MAGENTA + "  (Ctrl+C pour revenir au menu depuis un affichage en boucle)\n" + Fore.RESET)

# --- Générateurs IPv4 ---
def gen_loopback_ipv4():
    a = 127
    b = random.randint(0, 255)
    c = random.randint(1, 254)
    d = random.randint(1, 254)
    return f"{a}.{b}.{c}.{d}"

def gen_private_10():
    return f"10.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(1,254)}"

def gen_private_192_168():
    return f"192.168.{random.randint(0,255)}.{random.randint(1,254)}"

def gen_private_172():
    second = random.randint(16,31)
    return f"172.{second}.{random.randint(0,255)}.{random.randint(1,254)}"

def gen_link_local_ipv4():
    return f"169.254.{random.randint(0,255)}.{random.randint(1,254)}"

SIMULATED_GENERATORS = [
    ("Loopback IPv4 (127/8)", gen_loopback_ipv4),
    ("Private 10/8", gen_private_10),
    ("Private 192.168/16", gen_private_192_168),
    ("Private 172.16-31/16", gen_private_172),
    ("Link-local IPv4 (169.254/16)", gen_link_local_ipv4),
]

def simulated_ip(choice=None):
    if choice is None:
        name, fn = random.choice(SIMULATED_GENERATORS)
        return fn(), name
    else:
        try:
            idx = int(choice)
            idx = max(0, min(idx, len(SIMULATED_GENERATORS)-1))
            name, fn = SIMULATED_GENERATORS[idx]
            return fn(), name
        except Exception:
            name, fn = random.choice(SIMULATED_GENERATORS)
            return fn(), name

# --- Fake Tor info ---
def fake_tor_status():
    exit_node, _ = simulated_ip()
    hops = []
    for _ in range(3):
        hop_ip, _ = simulated_ip()
        hops.append(hop_ip)
    circuit = []
    prev = None
    for h in hops:
        if h != prev:
            circuit.append(h)
        prev = h
    return {
        "status": "CONNECTED",
        "exit_node": exit_node,
        "circuit": circuit
    }

# --- IPv4 reserved detection ---
def is_reserved_ipv4(ip_str):
    try:
        parts = [int(p) for p in ip_str.split(".")]
        if len(parts) != 4:
            return False
        a,b,c,d = parts
        if a == 127 or a == 10:
            return True
        if a == 192 and b == 168:
            return True
        if a == 172 and 16 <= b <= 31:
            return True
        if a == 169 and b == 254:
            return True
        return False
    except Exception:
        return False

# --- Geolocation (ip-api.com) ---
def geolocate_ip(ip):
    if requests is None:
        return False, "Module 'requests' non disponible."
    url = f"http://ip-api.com/json/{urllib.parse.quote(ip)}"
    try:
        r = requests.get(url, timeout=6)
    except Exception as e:
        return False, f"Erreur réseau : {e}"
    try:
        data = r.json()
    except Exception:
        return False, "Réponse non-JSON reçue."
    if data.get("status") == "success":
        return True, data
    else:
        return False, f"Service a répondu : {data.get('message','échoué')}"

# --- Création carte HTML ---
def create_map_html(lat, lon, popup_html, out_filename):
    safe_name = out_filename.replace("/", "_").replace("\\", "_")
    path = f"{MAP_OUTPUT_DIR.rstrip('/')}/{safe_name}"
    html = f"""<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>DreamLover — IP Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>html,body,#map{{height:100%;margin:0;padding:0}}</style>
</head>
<body>
<div id="map"></div>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
  var lat = {lat};
  var lon = {lon};
  var map = L.map('map').setView([lat, lon], 4);
  L.tileLayer('https://{{s}}.tile.openstreetmap.org/{{z}}/{{x}}/{{y}}.png', {{
    maxZoom: 19,
    attribution: '© OpenStreetMap contributors'
  }}).addTo(map);
  var redIcon = L.circleMarker([lat, lon], {{radius:8, color: 'red', fillColor: 'red', fillOpacity: 0.9}});
  redIcon.addTo(map).bindPopup({json.dumps(popup_html)});
</script>
</body>
</html>
"""
    try:
        with open(path, "w", encoding="utf-8") as f:
            f.write(html)
        return True, path
    except Exception as e:
        return False, f"Erreur écriture fichier HTML: {e}"

# --- IP info interactive ---
def ip_info_interactive():
    print()
    ip = input("Entre l'adresse IPv4 à géolocaliser > ").strip()
    if not ip:
        print(Fore.RED + "Aucune IP fournie." + Fore.RESET)
        return
    parts = ip.split(".")
    if len(parts) != 4 or any(not p.isdigit() or not (0 <= int(p) <= 255) for p in parts):
        print(Fore.RED + "Format IPv4 invalide." + Fore.RESET)
        return
    if is_reserved_ipv4(ip):
        print(Fore.YELLOW + f"L'adresse {ip} est réservée/private. Géoloc non applicable." + Fore.RESET)
        return
    if requests is None:
        print(Fore.RED + "Module 'requests' non installé." + Fore.RESET)
        return
    print(Fore.BLUE + "Géolocalisation via ip-api.com..." + Fore.RESET)
    ok, result = geolocate_ip(ip)
    if not ok:
        print(Fore.RED + f"Géoloc impossible: {result}" + Fore.RESET)
        return
    data = result
    country = data.get("country","N/A")
    region = data.get("regionName","N/A")
    city = data.get("city","N/A")
    lat = data.get("lat")
    lon = data.get("lon")
    isp = data.get("isp","N/A")
    query = data.get("query", ip)
    print(Style.BRIGHT + Fore.GREEN + f"\nRésultat pour {query} :" + Style.RESET_ALL)
    print(Fore.CYAN + f" - Pays: {country}" + Fore.RESET)
    print(Fore.CYAN + f" - Région: {region}" + Fore.RESET)
    print(Fore.CYAN + f" - Ville: {city}" + Fore.RESET)
    print(Fore.CYAN + f" - Latitude: {lat}  Longitude: {lon}" + Fore.RESET)
    print(Fore.CYAN + f" - ISP: {isp}\n" + Fore.RESET)
    popup = f"<b>{query}</b><br/>{city}, {region}, {country}<br/>lat: {lat}, lon: {lon}"
    out_file = f"ip_map_{query.replace(':','_')}.html"
    ok, path_or_err = create_map_html(lat, lon, popup, out_file)
    if not ok:
        print(Fore.RED + path_or_err + Fore.RESET)
        return
    print(Fore.GREEN + f"Carte créée: {path_or_err}" + Fore.RESET)
    try:
        webbrowser.open("file://" + path_or_err)
        print(Fore.YELLOW + "La carte s'ouvre dans le navigateur." + Fore.RESET)
    except Exception as e:
        print(Fore.RED + f"Impossible d'ouvrir le navigateur: {e}" + Fore.RESET)

# --- Boucle affichage IP simulées ---
def loop_show_ip(mode="direct", demo_random=False):
    print()
    mode_label = "DEMO (IPs IPv4 aléatoires)" if demo_random else ("Tor" if mode=="tor" else "Direct")
    print(Fore.BLUE + f"[{now_str()}] Mode: {mode_label} — affichage toutes les {INTERVAL}s (Ctrl+C pour arrêter)" + Fore.RESET)
    if mode=="tor" and not demo_random:
        tor_info = fake_tor_status()
        print(Fore.YELLOW + f"Tor status: {tor_info['status']}" + Fore.RESET)
        print(Fore.MAGENTA + "Circuit : " + " -> ".join(f"[+] {h}" for h in tor_info["circuit"]) + Fore.RESET)
        print(Fore.CYAN + f"Exit node : [+] {tor_info['exit_node']}\n" + Fore.RESET)
    try:
        while True:
            ip, src = simulated_ip()
            tag = "Ton IP (via Tor)" if mode=="tor" else f"Ton IP ({src})"
            ts = now_str()
            print(Style.BRIGHT + Fore.GREEN + f"[{ts}] {tag} : " + Fore.CYAN + f"[+] {ip}" + Style.RESET_ALL)
            time.sleep(INTERVAL)
    except KeyboardInterrupt:
        print("\n" + Fore.MAGENTA + "Retour au menu principal..." + Fore.RESET)
        time.sleep(0.3)

# --- Menu ---
def show_menu():
    banner()
    print(Style.BRIGHT + "Menu principal:" + Style.RESET_ALL)
    print(Fore.YELLOW + "[+] 1)" + Fore.RESET + " Lancer le script (Direct)")
    print(Fore.YELLOW + "[+] 2)" + Fore.RESET + " Lancer le script via Tor (status affiché)")
    print(Fore.YELLOW + "[+] 3)" + Fore.RESET + " Mode démo — afficher IPs IPv4 aléatoires")
    print(Fore.YELLOW + "[+] 4)" + Fore.RESET + " Voir les types d'adresses disponibles")
    print(Fore.YELLOW + "[+] 5)" + Fore.RESET + " IP info (géolocaliser une IP et afficher la carte)")
    print(Fore.YELLOW + "[+] 6)" + Fore.RESET + " Crédits & infos")
    print(Fore.YELLOW + "[+] 7)" + Fore.RESET + " Quitter\n")

def show_address_types():
    print("\nTypes d'adresses disponibles :")
    for i, (name, _) in enumerate(SIMULATED_GENERATORS):
        print(f" {i}) {name}")
    print()
    input("Appuie sur Entrée pour revenir au menu...")

def credits():
    print()
    print(Style.BRIGHT + Fore.CYAN + "Crédits — DreamLover" + Style.RESET_ALL)
    print(" - Création : DreamLover")
    print(" - Plages utilisées : loopback (127/8), private (10/8, 192.168/16, 172.16-31), link-local (169.254).")
    print(Fore.YELLOW + "\nDISCLAIMER: Outil à usage esthétique. Seule la fonction 'IP info' réalise une requête réseau pour géolocaliser.\n" + Fore.RESET)

def prompt_choice():
    try:
        choice = input(Style.BRIGHT + Fore.MAGENTA + "Choisis une option (1-7) > " + Style.RESET_ALL).strip()
        return choice
    except (KeyboardInterrupt, EOFError):
        print("\n")
        return "7"

# --- Main loop ---
def main():
    while True:
        show_menu()
        choice = prompt_choice()
        if choice == "1":
            loop_show_ip(mode="direct", demo_random=False)
        elif choice == "2":
            loop_show_ip(mode="tor", demo_random=False)
        elif choice == "3":
            loop_show_ip(mode="direct", demo_random=True)
        elif choice == "4":
            show_address_types()
        elif choice == "5":
            ip_info_interactive()
            input("\nAppuie sur Entrée pour revenir au menu...")
        elif choice == "6":
            credits()
            input("Appuie sur Entrée pour revenir au menu...")
        elif choice == "7":
            print(Fore.GREEN + "Merci d'avoir utilisé DreamLover — Mod Menu IP Checker. À bientôt !" + Fore.RESET)
            break
        else:
            print(Fore.RED + "Option invalide — réessaye." + Fore.RESET)
            time.sleep(0.5)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(Fore.RED + "Une erreur inattendue est survenue :" + Fore.RESET, e)
        sys.exit(1)
